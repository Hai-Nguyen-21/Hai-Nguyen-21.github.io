[{"content":"Khi mọi người nhắc đến giải thuật thì thường liên tưởng tới những kiến thức cao siêu, và đúng là nó cao siêu thật\u0026hellip; Tuy nhiên để enjoy cái moments này thì các em phải trải qua từ những thứ rất cơ bản, và cái series này dành cho các bạn.\nĐầu tiên chúng ta phải tìm hiểu giải thuật là gì chứ nhỉ?\nDisclaimer: Trong series này mình hướng tới những bạn mới học lập trình và ngôn ngữ mình sử dụng chính là C và Java.\n Khái niệm  Theo như Wikipedia viết: “Giải thuật là một thuật toán lấy đầu vào là một bài toán và trả về kết quả là một lời giải cho bài toán đó, thường là sau khi cân nhắc giữa một loạt các lời giải có thể. Hầu hết các thuật toán được nghiên cứu bởi các nhà khoa học máy tính để giải quyết các bài toán đều là các thuật toán tìm kiếm. Tập hợp tất cả các lời giải có thể đối với một bài toán được gọi là không gian tìm kiếm…”. Đọc thấy hack não chưa, nhưng để mình túm gọn lại: “Giải thuật (hay còn gọi là Algorithms) là một tập hợp các câu lệnh được viết theo một thứ tự nào đó để có thể giải quyết được vấn đề và thu được kết quả mong muốn. Giải thuật thì độc lập với ngôn ngữ lập trình cho nên một giải thuật sẽ có thể được triển khai trên nhiều ngôn ngữ lập trình”.\n“Ơ vậy cứ giải được bài toán thì gọi là giải thuật sao?” Dĩ nhiên là không rồi, bên cạnh việc giải quyết được vấn đề chúng ta cũng phải để ý tới những đặc điểm sau:\n Tính xác định: Giải thuật phải nên rõ ràng và không được mơ hồ. Kết quả đầu ra: Dĩ nhiên rồi, chúng ta phải trả về được kết quả mong muốn của đề bài. Tính dừng: Mỗi một cách giải chúng ta phải xem xét được tính dừng của bài toán, chắc các bạn không muốn máy tính của mình xảy ra một chuỗi vòng lặp vô hạn đâu nhỉ :))) Tính phổ biến: Một bài giải thuật phải được áp dụng và giải quyết được các vấn đề tương tự. Tính hiệu quả: Ngoài giải quyết được bài toán thì chúng ta cũng phải chú ý về thời gian thực thi và tài nguyên cho phép.  \tĐọc đến đây chắc các bạn cũng đã mường tượng được các khái niệm cơ bản về giải thuật rồi đúng không. Học đi đôi với hành, sau lý thuyết chúng ta sẽ tới một bài tập nho nhỏ để hiểu rõ hơn về giải thuật nhó.\nBài tập  Bài 1: Cho một dãy số nguyên dương n phần tử, nhập số k tùy ý từ bàn phím, hãy kiểm tra xem số k đó có trong mảng số nguyên không.\nKhi đứng trước bài toán như này các bạn sẽ dự tính làm như nào? Một người thầy của tôi có dạy lúc mới đầu học môn Java 1 là: “Bản chất của việc tìm kiếm là phải\u0026hellip;tìm và so sánh”. Đúng thế, như bài toán trên, các bạn sẽ phải tìm và so sánh từng phần tử của nó một, đến khi nào ta tìm thấy thì chỉ việc ném ra kết quả thôi. Vậy bây giờ hãy mở máy lên bắt tay viết code thôi nào:\nỞ đây mình có một hàm đặt tên là kiemTraSoK với 3 tham số đầu vào gồm: mảng số nguyên (arr[ ]), số mà chúng ta cần tìm (n), và kích thước của mảng (size). Hàm này ta sẽ có kiểu trả về là int. “Em không muốn trả về kiểu int, kiểu khác được không ạ?” Ok luôn nhé, kiểu trả về ở đây chúng ta có thể tùy biến theo từng dạng đề bài, ở đây ta có thể trả về kiểu boolean… Như đã nói bên trên, việc đầu tiên chúng ta cần làm đó là tìm, hay là đi dò từng phần tử có trong mảng, vậy có những cách nào để ta làm được điều đó ? Có rất nhiều cách tuy nhiên trong series này mình sẽ hướng tới những cách đơn giản và dễ thực hiện nhất.\nNhìn ở dòng 6, mình có một vòng lặp với điểm bắt đầu là bằng 0, điểm dừng của vòng lặp này là sẽ nhỏ hơn kích thước mảng và mỗi lần lặp nó sẽ tăng lên 1 đơn vị. Vậy tức là khi điểm i vẫn còn đúng trong điều kiện trên nó sẽ vào trong và kiểm tra các điều kiện bên trong vòng lặp.\nNhìn ở dòng 7, mình có một câu điều kiện if, ở đây mình đang so sánh GIÁ TRỊ TẠI VỊ TRÍ THỨ I với số n cần tìm. Ở đây mình toán tử == để kiểm tra số với số, ( đừng nhầm lẫn với toán tử = nhé :v ). Khi điều kiện trong if đúng thì sao ? Khi điều kiện if đúng tức là ta đã tìm ra được số n có trong mảng rồi, như vậy ra sẽ dừng việc kiểm tra và trả về số 1. Còn nếu như điều kiện if sai thì ta sẽ tiếp tục thực hiện vòng lặp là tăng lên 1 đơn vị sau đó kiểm tra tiếp với điều kiện dừng. Nếu như vòng lặp kết thúc mà ta vẫn chưa tìm được số thì sẽ trả về kết quả là 0.\nĐây chính là hàm main của mọi người, vì hàm trên có kiểu trả về là một số nguyên nên ta sẽ khai báo một biến (check) để “tiếp nhận” giá trị trả về đó rồi đem đi tiến hành kiểm tra. À, khi truyền tham số cho hàm nhớ để đúng vị trí nhé. Như đã nói bên trên, khi tìm thấy số đó thì ta sẽ trả về giá trị là 1, ngược lại là giá trị 0. Ở đây ta so sánh biến (check) kia, nếu như bằng 0 thì thông báo không tìm thấy số họ cần tìm, còn nếu điều kiện if sai thì sẽ nhảy xuống điều kiện else, tức là tìm thấy số đó. Trường hợp này là không tìm thấy Trường hợp này là chúng ta tìm thấy\nĐó, rất đơn giản phải không, chúng ta cứ suy nghĩ đơn giản để có một hướng làm, sau đó sẽ từ đó thực hiện trên các dòng code và tối ưu dần. Bài tập này mọi người hãy code lại trên máy, còn bạn nào chưa clear về mạch chạy thì mình khuyên bạn nên giải tay từng bước để có thể hiểu được. Bài hôm nay đến đây thôi, chào mọi người. ","description":"Học giải thuật từ cơ bản đến khá","id":0,"section":"posts","tags":["C++","Giải thuật"],"title":"Tìm kiếm một số trong mảng","uri":"https://hai-nguyen-21.github.io/posts/giaithuat/"},{"content":"“Anh em sinh đôi ?”\nHey yo what’s up, chào mừng các bạn đã quay trở lại với cái bờ lóc của mình. Cơ duyên để mình lên bài này nó cũng éo le lắm, hôm đó thầy lớp mình có kiểm tra nhanh bài của mấy bạn trong lớp và có hỏi “Thế tại sao chỗ này em không dùng Interface và lại dùng Abstract Class?”, “Thế sự khác nhau giữa hai cái này là gì?”… và 101+ câu hỏi khác liên quan đến 2 đứa này và các bạn lớp mình có vẻ khá lúng túng trước câu hỏi này, ( mình cũng mất 2p để định vị lại câu trả lời sao cho “có não nhất” ). Cho nên mình lên bài này để mọi người cùng thảo luận và hiểu rõ hơn về sự khác nhau giữa Interface và Abstract Class nhé! Lẹt goooo.\nDisclimer: Ở bài viết này mình sẽ không đi sâu vào khái niệm hay cách khai báo đâu nhé, nếu bạn nào muốn tìm hiểu kĩ hơn thì có thể đọc bài này trước rồi quay lại nhé!\nLink 8p: https://hai-nguyen-21.github.io/posts/oop2/\n Abstract Class: các bạn có thể hiểu đây như một lớp cha , có những đặc tính và hành động chung, bao quát nhất dành cho các lớp con khác.  Ở trên mình đã tạo ra một lớp abstract Xe với thuộc tính là động cơ, cùng với phương thức là khởi động và dừng động cơ. Tuy nhiên Xe là một cái gì đó khá chung chung và trừu tượng, nó có thể là bất kì loại xe nào và khi đó các lớp con extends lại sẽ định nghĩa riêng cho từng lớp. Và khi đó thằng con (child class) chỉ có thể có duy nhất 1 lớp cha, có tính chất giống cha (abstract class) đó.\n Interface: Các bạn có thể hiểu Interface như một bản thiết kế, và bản thiết kế này sẽ liệt kê tất-cả-các-chức-năng cơ bản nhất mà một dự án cần sử dụng. Cơ chế của Interface cũng không khác gì bản hợp đồng, tức là khi ta “thực thi” hợp đồng này sẽ phải tuân theo các điều khoản trong đó, không có ngoại lệ.  “Thế nghe chừng dùng Interface bất tiện quá nhỉ, nếu ví dụ có 10 class implements một Interface nhưng chỉ có 5 class cần thêm 1 chức năng nữa, chẳng nhẽ phải viết lặp lại 5 lần trong mỗi class hay lại tạo 1 Interface mới cho riêng 5 class này?”\nĐúng, nhưng nó chỉ đúng với Java 1,2,3,4,5,6,7 thôi, lên Java 8 đã xuất hiện thêm phương thức default và static sẽ giải quyết vấn đề này. Còn chưa kể 2 phương thức này còn có body code nhé.\nĐó thấy chưa, khi implements lại FirstInterface ta không cần implements default method.\nQuay trở lại với Interface và Abstract Class, theo một cách ngắn gọn, khi một class extends một Abstract Class thì mối quan hệ này được gọi là is – a (Ô tô là Xe) , còn khi một class implements một Interface thì mối quan hệ này là can – do (Ô tô có thể chạy).\nVậy túm cái quần lại, khi bạn muốn thể hiện các lớp có mối quan hệ cha con với nhau, ví dụ như voi, chó, hổ… đều là Animal.\nCòn về Interface, mục đích của Interface là thể hiện tính đa hình, khả năng thực hiện các hành động khác nhau. Nếu bạn muốn thể hiện tính đa kế thừa thì dùng Interface. Ví dụ như mình muốn hỗ trợ người dùng thanh toán qua nhiều ngân hàng, mình sẽ tạo môt Interface PayMoney, sau đó nếu muốn bao nhiêu ngân hàng thì chỉ việc thực thi interface này thôi.\nKết thúc bài viết mong các bạn có thể hiểu được phần nào về khái niệm và phân biệt được Interface và Abstract Class nhé, thầy mình thì khuyên dùng Interface :v.\nBài viết tham khảo sách: Head First Java.\n","description":"Nhà tôi 3 đời không phân biệt được nhưng đến đời tôi thì phân biệt được nhờ đọc bài viết này...","id":1,"section":"posts","tags":["java","học thuật"],"title":"Anh em sinh đôi - Abstract Class và Interface","uri":"https://hai-nguyen-21.github.io/posts/so-s%C3%A1nh-l%E1%BB%9Bp-abtract-v%C3%A0-inteface/"},{"content":"Công nghệ thông tin – Những câu chuyện trong “Ngành”\nHeyyo, chào mừng các bạn đến với blog của mình, mình là Hải, hiện đang là sinh viên năm 2 ngành công nghệ thông tin.\nCó thể các bạn đã từng nghe những câu nói kinh điển từ những cánh báo trí như là “Lương tháng khởi điểm 1000$”, “Vua của mọi nghề”… hay là nghe phong phanh thiên hạ đồn thổi về một ông anh Bính Tý học cơ khí Bách Khoa, tất cả đều nói về độ hào nhoáng mà ngành này mang lại vậy liệu những điều trên có đúng không? Trong bài viết này, mình sẽ cùng các bạn tìm hiểu kĩ hơn về ngành này thông qua những câu hỏi kinh điển từ những kẻ ngoại đạo, để các em năm nhất có thể đem đi ứng phó với bạn bè, hay là biết cách từ chối khéo khi có ai đó nhờ cài win máy hay sửa tivi nhé.\n*Disclaimer: Những kiến thức mình chia sẻ dưới đây là thành quả của mình tìm hiểu qua sách báo và tâm sự của thầy cô, có thể sẽ có những luận điểm hơi phiến diện, các bạn đọc với tâm trí tìm hiểu thôi nhé!*\n Học CNTT là làm gì?  Đầu tiên ta phải tìm hiểu về khái niệm ngành này trước. Theo trang WordNet của trường Đại học Princeton có viết “Công nghệ thông tin (Information Teachnology) là một ngành kỹ thuật sử dụng máy tính và viễn thông để thu nhận, lưu trữ và truyền tải thông tin.” Trong một bài báo của 2 tác giả Harold J. Leavitt và Thomas L. Whisler năm 1958 có nói “Công nghệ mới này vẫn chưa có tên riêng. Chúng tôi sẽ gọi nó là công nghệ thông tin”.\n“Lý thuyết lắm thế nhờ, vậy rốt cuộc học cái này xong có sửa được máy giặt không?”\nẤy đừng nóng, thực ra ngành này rất rộng, mình cũng khá khó để trả lời trọn vẹn cho các bạn câu này vì ngành này rất đa dạng, chưa kể mỗi công ty sẽ có một mô hình riêng, các chức vụ cũng có thể chồng chéo lên nhau. Tuy nhiên sau khoảng 1 giờ tìm kiếm 7749 các website thì mình cũng có thể tổng hợp lại cho các bạn những vị trí “cơ bản” trong ngành như sau:\nNhìn vào sơ đồ trên các bạn có thể thấy ngành này của chúng ta vô cùng rộng, thậm chí mình thấy còn chưa đủ lắm đâu nhưng về cơ bản các bạn cũng có thể hình dung được phần nào về những lĩnh vực trong ngành. Có thể thấy rằng công việc của tụi mình đâu chỉ có ngồi cắm mặt máy tính viết code, bên cạnh đó còn có những lĩnh vực thú vị như làm sản phẩm (các vị trí liên quan đến product), thiết kế (design), cầu nối giữa client và team dev (BrSE, IT Compor)… Như vậy ngành IT không phải dành cho mấy ông “đầu to mắt trố”, cù lì, trầm tính đâu nhé, trong ngành cũng có những vị trí đòi hỏi sự giao tiếp, sáng tạo, thấu hiểu mọi người.\n “Con gái có học CNTT được không?”  Trước khi trả lời câu này tôi sẽ cho các ông xem thống kế trên TopCV.\nThời điểm ghi nhận: 5/2020\n( Tổng hợp dựa trên tổng số tin đăng tuyển trên các kênh tuyển dụng IT lớn nhất: ITViec, Vietnamworks, CareerBuilder, TopDev, TopCV)\n\tBao gồm nhóm lập trình viên, tester, QA, Design, BA, nhân sự làm trong ngành, thống kê theo TopDev)\nNhư các bạn cũng đã thấy, ngành CNTT thực sự rất hot trong những năm gần đây, và dự báo sẽ tăng hơn nữa trong tương lai. Quay lại với câu hỏi trên, nhìn biểu đồ thứ 2 các bạn cũng thấy tuy số lượng nam nhân viên có hơi áp đảo nhưng số lượng nhân viên nữ cũng không quá ít, trong ngành có rất nhiều vị trí cần sự tỉ mỉ, mềm dẻo khi giao tiếp chính vì vậy các bạn nữ có thể tự tin theo học, tuy nhiên theo lời cô giáo mình thì các bạn nữ sẽ có hơi “vất vả” hơn các bạn nam trong những giai đoạn đầu. Nhưng nếu bạn có niềm đam mê to lớn với máy móc thì những khó khăn kia cũng không là gì so với chúng ta đúng không.\n “Lương khởi điểm của ngành này chắc cao lắm?”  Do mình vẫn đang đi học nên không thể trả lời câu hỏi này được, tuy nhiên theo cá nhân của mình nghĩ lương cao hay thấp đều do năng lực của chính bản thân, bạn bỏ ra được nhiều thứ giá trị cho công ty thì chắc chắn con số bạn nhận lại cũng không hề nhỏ. Có một idol từng nói “Muốn ngồi ở vị trí không ai ngồi được phải làm được những việc không ai làm được” :)))). Chính vì thế mà ngành CNTT phải bỏ ra rất nhiều chất xám, hơn hẳn các công việc văn phòng khác.\nAnh A làm nhân viên văn phòng, anh B thì làm lập trình, cả hai đều làm 8 giờ mỗi ngày nhưng lương anh A chỉ có 7 triệu, anh B là 10 triệu, vậy ai là người nhiều tiền hơn? Đứa trẻ 3 tuổi cũng có thể trả lời được câu hỏi trên, tuy nhiên nếu ta suy nghĩ sâu hơn sẽ thấy, công việc của anh A có vẻ mang tính chất lặp lại mỗi ngày còn công việc anh B thì mỗi ngày đều phải giải quyết một vấn đề mới, nếu chưa giải quyết được còn phải OT thêm giờ để không cháy deadline, chưa kể còn khá nhiều áp lực khác nữa cho nên tiền lương hơn cũng đúng.\nCòn ở câu hỏi này, thầy mình cũng có nói mà mình thấy rất đúng. Lúc mới ra trường các bạn sinh viên đều sẽ bắt đầu với vị trí như fresher hoặc intern, kiến thức trong trường chắc chắn không thể giúp các bạn có thể nhảy vào dự án của công ty rồi quẩy nhiệt tình được, lúc này chúng mình nên đi làm để lấy kinh nghiệm làm trọng, trợ cấp hay lương nên xếp thứ 2, sau khi đi làm được một thời gian rồi, nếu bạn có nỗ lực, cố gắng, và giúp đỡ được công ty thì mình tin chắc cấp trên sẽ hiểu được thành quả mà bạn tạo ra.\nTúm cái quần lại, thì chúng ta chỉ cần cố gắng, tạo ra được giá trị, nâng cấp bản thân từng ngày thì chắc chắn các bạn sẽ nhận lại được một mức lương hợp lý, học đi nhé!\n 101+ câu hỏi ngoài lề nho nhỏ.  Dưới đây là những câu hỏi mà mình nhận được từ người thân và bạn bè trong suốt 1 năm học qua, và cũng có những câu hỏi mình đã khảo sát được từ các bé 2k3, 2k4 hay các bạn khác ngành nữa.\nQ: Học CNTT sau này đi làm nghề sửa máy tính có phải không?\nKHÔNGGGG. Như các bạn đã thấy ở phần 1, mình có chỉ ra trong ngành có rất nhiều ngành nghề trong CNTT, sửa máy tính thì thấy cũng có liên quan đến máy móc đấy nhưng lại ở một mảng rất khác nhé.\nQ: Học CNTT có cần phải giỏi Toán không?\nCâu trả lời là “Có” và “Không”. Tùy vào công việc mà bạn đang làm, có những mảng bạn chỉ cần biết những thứ toán cơ bản nhưng có những mảng bạn cần phải vận dụng nội dung suốt 4 năm học trên Đại học cũng chưa chắc giải quyết được vấn đề. Tuy nhiên nếu bạn học giỏi Toán thì sẽ là một bước đệm vững chắc vì nếu giỏi Toán thì tức là bạn cũng có một lối suy nghĩ rất logic mà trong ngành này suy tư logic vô cùng quan trọng.\nQ: Học sinh cấp 3 cần những gì cho ngành CNTT?\nỞ cấp 3 bạn có thể tập trung học những môn như Toán, Tin học để bồi đắp lối suy nghĩ logic, tham gia các cuộc thi liên quan đến Tin học vì nếu bạn học giỏi môn Pascal thì khi lên Đại học bạn học môn Nhập môn lập trình sẽ đỡ vất vả hơn.\nQ: Nên học ngôn ngữ lập trình nào để kiếm nhiều tiền?\nThầy mình từng nói, ngôn ngữ chỉ là công cụ, nếu bạn giỏi ngôn ngữ nhưng bạn không có ý tưởng để làm thì cũng bằng không. Mục đích của lập trình là giải quyết vấn đề, vấn đề càng khó thì càng ra tiền, chính vì vậy các bạn không nên tôn sùng ngôn ngữ quá, mà thay vào đó nên rèn luyện kỹ năng cho tốt.\nQ: Có cần học Đại học mới làm được nghề này không?\nHiện nay mình cũng không theo học Đại học mà mình chỉ đang học Cao Đẳng, tuy nhiên một tấm bằng Đại học sẽ là chìa khóa để chứng minh cho nhà tuyển dụng thấy công sức bạn bỏ ra. Ở trường Đại học sẽ giúp bạn học được những môn nền để giúp bạn lối suy nghĩ logc và giải quyết vấn đề còn để phát triển xa hơn thì lại ở bản thân các bạn, tuy nhiên các bạn học Cao đẳng hay đang học trái ngành muốn sang CNTT cũng đừng nản, nếu không có bằng Đại học thì các bạn cũng có thể đi học thêm ở trung tâm, tạo cho mình một profile thật xịn để có thể show cho nhà tuyển dụng thấy.\nTúm cái quần lại, nếu có điều kiện thì theo học Đại học nhưng đừng học đại nhé!\nQ: Sinh viên trái ngành có thể học được CNTT không?\nCác bạn sinh viên trái ngành có thể theo học CNTT được, tuy nhiên các bạn có xuất phát điểm muộn hơn các bạn khác nên phải cố gắng hơn, đừng nản mà hãy cố gắng học hỏi, kiếm cho mình một người thầy để khỏi bơi trong đống kiến thức vô tận này nhé :)))\nQ: Ngành này có cần giỏi tiếng Anh không?\nCó nhé, trong ngành mình rất cần tiếng Anh để các bạn có thể đọc hiểu tài liệu trên mạng, gặp bug còn biết fix, tuy nhiên không bắt buộc các bạn phải có bằng IELTS 8 hay 9 đâu (có thì càng tốt), nếu bạn nào ít thời gian thì thể học để thi Toeic, quan trọng các bạn cần đọc hiểu được, nghe được để xem các video bên nước ngoài, còn vụ nói thì các bạn có thể tự luyện hoặc rủ bạn bè tham gia một khóa trên Cambly có thể học nói tiếng Anh 1-1 với người bản xứ.\nTrên đây là những điều mình hay và hiểu lầm của mọi người về ngành CNTT, mong sẽ giúp được các bạn, nếu các bạn thấy có vấn đề có thể comment bên dưới để mình rút kinh nghiệm trong các bài viết sau, nếu các bạn còn có những câu hỏi gì về kiến thức học thuật hay kiến thức xung quang ngành thì hãy comment bên dưới để mình tổng hợp và viết bài tiếp nhé. Dịch này ở nhà thôi nha, Stay safe and Stay home nha các bạn. Bái bai\n","description":"Ở đây chúng tôi tâm sự, chia sẻ nhưu những người anh em :v","id":2,"section":"posts","tags":["tâm sự"],"title":"Công nghệ thông tin – Những câu chuyện trong “Ngành”","uri":"https://hai-nguyen-21.github.io/posts/c%C3%B4ng-ngh%E1%BB%87-th%C3%B4ng-tin/"},{"content":"Default Method\n Như chúng ta đã biết từ java 7 đổ xuống thì trong các method trong interface chỉ được phép miêu tả (declaration) mà không được phép định nghĩa nó (definition). Nhưng đối với java 8 thì có thêm 2 khái niệm mới về interface đó là default method.  Trong bài viết lần này, tôi sẽ chỉ giới thiệu về default method thôi nhé.\n Default Method- Phương pháp mặc định:  1.1 Cách viết:\n\tPublic interface DAO{\n\tdefault void log(String mss){\n\tSystem.out.println(“hi “ + mss);\n}\n}\n+ Tại đó chúng ta có thể viết, định nghĩa method đó.\n+ Khi 1 lớp interface extends lớp interface đó có 3 lựa chọn\n Có thể không override default method đó Có thể override rồi viết lại định nghĩa cho nó Có thể đổi từ default method sang abstract  + Nếu một abstract class/concrete class implements từ interface IDBManager trên thì chỉ có 2 sự lựa chọn:\n Nếu không làm gì với method log(message) thì method log() sẽ được thừa kế từ interface. Có thể overriden lại method log(message) nhưng method phải ở dạng abstract hoặc bình thường (không có default method cho class)  Ví dụ:    public abstract class AbstractDBManager implements IDBManager{\n\tpublic abstract void log(String message);\n}\npublic class BearDBManager implements IDBManager{\n\tpublic void log(String message){\n System.out.println(\u0026ldquo;BEAR: \u0026quot; + message);\n }\n}\n1.2 Mục đích\nGiả sử trong quá trình phát triển, người ta muốn bổ sung 1 method vào interface là search(message) cho phép tìm kiếm thông tin sinh viên , như vậy như ở phiên bản java 7, nếu thêm 1 method vào interface thì bắt buộc phải sửa chữa tất cả các concrete classes implement từ interface đó, cụ thể ở đây là ta phải implement method search (message) .\nVD:\nnay với java 8 muốn thêm vào 1 method trong interface ta chỉ việc đặt từ khoá default vào như sau:\npublic interface IDBManager{\n\t//\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\n public default void Search(String message){\n //\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;-\n }\n}\ntất cả các classes implements từ DAOsv sẽ được kế thừa method Search (message) và chúng ta không phải sửa chữa lại các classes đó. Mục đích của default method ra đời là để bổ sung thêm các method vào interface mà không phải thay đổi những implementation code trước đây (đảm bảo tính tương thích).\nLợi ích: Trong quá trình phát triển, người ta muốn thêm 1 vài method nữa vào trong lớp interface. Nếu như ở các java trước thì khi thêm 1 method vào interface thì toàn bộ những lớp nào implements interface đó đều cần phải override method đó nữa -\u0026gt; gây ra nhiều sự bất tiện Còn ở trong java 8 thì chúng ta chỉ cần để method đó thành dạng default method là done :v. Class nào cần dùng thì override còn không thì không cũng được Một trong những tiện ích lớn nhất của default method đó là: Sử dụng trong việc dùng Comparator với Comparator.comparing() và Comparator.thenComparing()  + Ví dụ: ở những java phiên bản trước thì phải\n+ Còn ở java 8 thì tiện lợi hơn nhiều:\nMột số lưu ý khi sử dụng default method:  + Khi 1 class implement 2 interface khác nhau và 2 interface đấy có tên giống nhau thì compiler của java sẽ báo lỗi , vì nó không xác định được default method nào sẽ được chọn trong nhiều default method giống khai báo.\n+ Nếu chúng ta overriden 1 method của java.lang.Object ví dụ như equals, trình biên dịch sẽ thông báo cho chúng ta 1 error \u0026ldquo;A default method cannot override a method from java.lang.Object\u0026rdquo;, Java 8 không cho phép override method của Object dưới dạng default method.\n","description":"Java 8 mở ra cho cho chúng ta những thứ khiến cộng việc học lập trình trở nên thú vị hơn...","id":3,"section":"posts","tags":["java","java 8","học thuật"],"title":"Default Mothod - trông cũ mà mới.","uri":"https://hai-nguyen-21.github.io/posts/default-method/"},{"content":"Lambda Expression- Tính năng thú vị của Java 8\n Định nghĩa  - Là một hàm không có tên (anonymous function) với các tham số (parameters) và nội dung thực thi (body).\n- Nội dung thực thi của Lambda expression có thể là một khối lệnh hoặc một biểu thức.\n- Dấu “-\u0026gt;” tách biệt các tham số và nội dung thực thi.\n Cú pháp  (argument-list) -\u0026gt; {body}\n+ Argument-list : danh sách tham số, có thể không có, có một hoặc nhiều tham số.\n+ Arrow-operator: toán tử mũi tiên được sử dụng để liên kết danh sách tham số và body của biểu thức.\n+ Body: nội dung thực thi, là 1 khối lệnh hoặc 1 biểu thức.\n Ví dụ  () -\u0026gt; \u0026ldquo;Hello\u0026rdquo; Không có tham số và trả về một chuỗi\n(double x) -\u0026gt; x + 1 Có một tham số x và trả về giá trị tham số tăng lên 1\n(int x, int y) -\u0026gt; x + y Có 2 tham số kiểu int và trả về tổng\n Một số quy tắc trong Lambda Expression Có thể bỏ qua kiểu dữ liệu của parameter truyền vào  (String msg) -\u0026gt; {System.out.println (msg);} =\u0026gt; (msg) -\u0026gt; {System.out.println (msg);}  Nếu không có parameter ,bỏ dấu () trống  () -\u0026gt; {System.out.println (“Hello”);}  Nếu chỉ có 1 parameter, có thể bỏ luôn dấu ()  (double x) -\u0026gt; x + 1 =\u0026gt; x -\u0026gt; x+1\n Nếu anonymous function chỉ có 1 câu lệnh , có thể bỏ dấu {}   (msg) -\u0026gt; {System.out.println (msg);} =\u0026gt; msg -\u0026gt; System.out.println (msg);  Nếu chỉ return 1 giá trị , có thể bỏ chữ return  x -\u0026gt; return x + 1 =\u0026gt; x -\u0026gt; x + 1  Ứng dụng  Duyệt List  Cách 1 – for i      for (int i = 0; i \u0026lt; listNV.size(); i++) {\n listNV.get(i).xuat();\n }\n Cách 2 – for each  for(NhanVien x:listNV){\n x.xuat();\n}\n Cách 3 – biểu thức Lambda  listNV.forEach(x -\u0026gt; {\n x.xuat();\n });\n Sắp xếp chuỗi  Cách cũ    public void sortByName() {\nComparator com = new Comparator\u0026lt; Staff \u0026gt;() {\n @Override\n public int compare(Staff o1, Staff o2) {\n return o1.getName ().compareTo(o2.getName ());\n }\n };\n listNV.sort(com);\n System.out.println(\u0026ldquo;DSNV sắp theo họ tên là:\u0026quot;);\n xuatDSNV();\n }\n Cách 1 – dùng Lambda theo Collections  public void sortByName () {\n Collections.sort(listNV, (Staff o1, Staff o2)\n -\u0026gt; {\n return o1.getName ().compareToIgnoreCase(o2.getName ());\n });\n System.out.println(\u0026ldquo;DSNV sắp theo họ tên là:\u0026quot;);\n xuatDSNV();\n }\n Cách 2 – cũng là Collections nhưng ngắn hơn 😊)  public void sortByName () {\n listNV.sort((o1, o2)-\u0026gt; {\n return o1.getName ().compareTo(o2.getName ());\n });\n System.out.println(\u0026ldquo;DSNV sắp theo họ tên là:\u0026quot;);\n xuatDSNV();\n","description":"Java 8 mở ra cho cho chúng ta những thứ khiến cộng việc học lập trình trở nên thú vị hơn...","id":4,"section":"posts","tags":["java","java 8","học thuật"],"title":"Lambda Expression và những điều thú vị..","uri":"https://hai-nguyen-21.github.io/posts/lambda-expression/"},{"content":"Tiếp nối bài viết trước, chúng ta dừng lại ở tính chất thứ nhất, hôm nay tôi sẽ giới thiệu tiếp cho các bạn 3 tính chất còn lại của lập trình hướng đối tượng nhé.\nTâm pháp tầng thứ hai : Encapsulation  Nghe đến đây chắc hẳn các bạn cũng đã mường tượng ra tính chất này nói về cái gì rồi đúng không? Và nội dung của tính chất này được hiểu như sau:\n“Tính đóng gói là một cơ chế liên kết dữ liệu và code chung với nhau thành một đơn vị duy nhất. Nó cũng được hiểu với mục đích che giấu dữ liệu của bạn để đảm bảo toàn vẹn dữ liệu từ những chỉnh sửa bên ngoài.”\nVậy tức là sao?\nNhưng trước khi vào thực hành ta nên đi qua chút lý thuyết nhé. Tính đóng gói có 4 kiểu phạm vi truy cập (Access Modifier) như sau:\n Default (mặc định) : Nếu như bạn không khai báo phạm vi truy cập thì Java sẽ hiểu mặc định phạm vi truy cập là default. Với default thì trong lớp (class) đó và trong gói (package) đó mới có thể nhìn thấy được. Private (riêng tư) : Nếu như bạn khai báo phạm vi truy cập là private thì chỉ có thể sử dụng ở ngay trong chính lớp đó thôi. Public (công khai) : Nếu như bạn khai báo ở dạng public thì mọi thông tin trong lớp đó đều có thể được nhìn thấy từ các lớp (class), các gói (package), hay là class con (subclass) Protected (được bảo vệ) : Nếu bạn khai báo ở dạng này thì lớp (class) đó, gói (package) đó, lớp con (subclass) đó đều có thể thấy được.  NOTE: Có thể nhiều bạn sẽ hiểu lầm về public và protected nhưng phạm vi của pubic nó rất rộng, bạn có thể truy cập vào 1 class với các thuộc tính được public từ package này sang package khác, còn protected thì không, nó chỉ hoạt động trong chính package của nó mà thôi.\nĐể dễ hiểu thì các bạn có thể xem ví dụ ở dưới đây\nCó phải từ những ví dụ trên mình đều lấy ví dụ cho các bạn như thế này đúng không:\nCode ở trên cơ bản là không sai, nó vẫn chạy và diễn ra bình thường, tuy nhiên không ai mong muốn một ngày đẹp trời bạn vào xem sản phẩm của mình và bị thay đổi dữ liệu tùm lum đúng không. Để giải quyết vấn đề đó cho nên ta cần phải private hết dữ liệu lại để tránh bị sửa code từ những tác nhân bên ngoài. “Ơ nhưng private rồi thì sao có thể truy cập được từ các class khác?” Chính vì thế nên Java mới có thêm 2 phương thức thần kỳ đó chính là Getter và Setter, hai phương thức này chuyên dùng để có thể Lấy và Ghi dữ liệu. Như vậy từ lần sau, chúng ta nên khai báo một lớp với những phạm vi truy cập ở dạng private để có thể bảo toàn dữ liệu và truy cập tới chúng thông qua phương thức Get và Set.\nNhìn qua một lượt ví dụ trên có bạn nào thắc mắc về dòng code này không?\nĐây được gọi là Constructor không tham số, Constructor này sẽ luôn được mặc định gọi ra kể cả khi bạn có khai báo hay không. Ngoài Constructor không tham số ta cũng có Constructor có tham số, riêng Constructor có tham số thì bắt buộc bạn phải khai báo. Constructor có tham số có nhiệm vụ giống với Get và Set, bạn có thể truyền dữ liệu vào đó mà không cần Get và Set.\nNhư vậy là các bạn đã hiểu về tính chất thứ 2 trong OOP rồi, tiếp theo ta sẽ đến với tính chất thứ 3 đó là tính trừu tượng.\nTâm pháp tầng thứ ba : Abstraction  Vậy trừu tượng nghĩa là sao? Theo mình thì trừu tượng cũng như một tảng băng chìm vậy, ta chỉ có thể nhìn được những bề nổi và nhận ra nó sẽ làm gì còn bề dưới tảng băng ta không hề hay biết nó to hay nhỏ, kích thước ra sao.\nVậy từ đây mình có thể giải thích ngắn gọn về tính chất này như sau:\n“Tính trừu tượng là một tiến trình ẩn các chi tiết trình triển khai và chỉ hiển thị tính năng tới người dùng. Tính trừu tượng cho phép bạn loại bỏ tính chất phức tạp của đối tượng bằng cách chỉ đưa ra các thuộc tính và phương thức cần thiết của đối tượng trong lập trình.”\nCó hai cách để ta có thể triển khai được tính trừu tượng:\n Sử dụng Abstract Class Sử dụng Interface  \t3.1. Abstract Class\nMột lớp được khai báo với từ khóa abstract tức là một lớp abstract. Lúc này bạn sẽ không thể sử dụng từ khóa “new”, có nghĩa là bạn không thể tạo instance từ một lớp trừu tượng. Cách duy nhất đó là dùng một lớp con kế thừa lại lớp abstract class. Để dễ hiểu mình có ví dụ như sau:\nBên trên mình có tạo ra một abstract class với phương thức rỗng là draw();. Sau đó mình có tạo thêm một lớp con là Rectangle kế thừa lại lớp Shape để sử dụng lại method. Kết quả:\nLúc này lớp abstract đóng vai trò như một base class, khai báo tất cả những method cơ bản và cần thiết nhất để các lớp khác có thể tái sử dụng mà không cần viết lại code. Tuy nhiên khi ta extends một class Abstract thì ta phải Override lại toàn bộ methods đã được khai báo.\n3.2. Interface Như ví dụ bên trên mình đã giới thiệu cho các bạn về Interface rồi. Trong Interface thì chỉ có thể khai báo các method rỗng (tức không có body code) để các lớp khác khi implements sẽ khai báo và sử dụng lại methods đó.\nTuy nhiên khi lên Java 8 thì Interface được hỗ trợ defaults methods, lúc này bạn có thể triển khai body code trong một Interface.\nĐể hiểu rõ hơn về defaults methods bạn có thể đọc bài viết này: Vậy sự khác nhau giữa Abstract class và Interface là gì?    Abstract Class Interface     Thể hiện tính trừu tượng \u0026lt;100%  Thể hiện tính trừu tượng 100% (\u0026lt; Java 8)   Lớp trừu tượng không hỗ trợ đa kế thừa Interface có hỗ trợ đa kế thừa   Lớp trừu tượng có thể có phương thức static, phương thức main và constructor. Không có phương thức static, phương thức main và constructor.\n\n   Từ khóa abstract để khai báo một lớp abstract Từ khóa interface để khai báo một lớp Interface.   Lớp trừu tượng có thể cung cấp trình triển khai của một Interface Interface không thể cung cấp trình triển khai cụ thể của lớp abstract.    \tCuối cùng là tính chất thứ 4, tính đa hình.\nTâm pháp tầng thứ tư : Polymorphism  Trong tiếng Anh, “poly” nghĩa là nhiều, “morph” có nghĩa là hình thức. Đa hình có thể là một biến, một chức năng, một đối tượng được đưa vào sử dụng dưới nhiều hình thức khác nhau.\n\tĐể dễ hiểu nhất về tính chất này, bạn có thể liên tưởng đến những diễn viên vậy, ở bộ phim này họ đóng vai ác, đến bộ phim sau họ đóng vai hiền. \tVậy ta phải sử dụng tính đa hình như thế nào trong lập trình OOP. Trước mắt ta phải hiểu rõ, khi nói đến đa hình là phải đi kèm với kế thừa. Bởi vì để một đối tượng nào đó có thể nhập vai vào một đối tượng khác thù chỉ có thể một đối tượng cha, và ở đây lớp cn sẽ phải ghi đè (Overriding) lại các phương thức của lớp cha.\nTa hãy cùng xem ví dụ dưới đây:\nNgoài ra ta còn có Overloading để thể hiện tính đa hình. Vậy sự khác biệt giữa Overriding và Overloading là gì?\n Overloading (nạp chồng) Đây là khả năng cho phép một lớp có nhiều thuộc tính, phương thức cùng tên nhưng với các tham số khác nhau về loại cũng như về số lượng. Khi được gọi, dựa vào tham số truyền vào, phương thức tương ứng sẽ được thực hiện.  Overriding (ghi đè) là hai phương thức cùng tên, cùng tham số, cùng kiểu trả về nhưng thằng con viết lại và dùng theo cách của nó, và xuất hiện ở lớp cha và tiếp tục xuất hiện ở lớp con. Khi dùng override, lúc thực thi, nếu lớp Con không có phương thức riêng, phương thức của lớp Cha sẽ được gọi, ngược lại nếu có, phương thức của lớp Con được gọi.  Để dễ hiểu các bạn có thể hiểu Overloading như sau: Nếu một lớp có nhiều phương thức cùng tên nhưng khác nhau về tham số hay kiểu dữ liệu thì đó chính là nạp chồng phương thức.\nNhư vậy mình đã giới thiệu cho các bạn về tất cả 4 tính chất trong OOP rồi. Hy vọng bài viết này sẽ giúp các bạn có cái nhìn bao quát hơn về lập trình hướng đối tượng, từ đó sẽ giúp các bạn hiểu rõ hơn về những kiến thức bao la phía sau.\nTài liệu tham khảo:\n Head First - Java. https://www.javatpoint.com/abstract-class-in-java  ","description":"OOP không phải là chủ đề dễ, những cũng không quá khó nếu chúng ta đầu tư tìm hiểu...","id":5,"section":"posts","tags":["oop","java","học thuật"],"title":"OOP - Những điều chưa kể (Phần 2)","uri":"https://hai-nguyen-21.github.io/posts/oop2/"},{"content":" [NHỮNG ĐIỀU CƠ BẢN VỀ OOP MÀ BẠN CHƯA BIẾT]\nNếu như những ai học lập trình thì không còn quá xa lạ với chủ đề này nhưng để hiểu nó thì không phải ai cũng có thể hiểu được luôn. Chính vì vậy hôm nay mình sẽ giới thiệu lại cho mọi người để có cái nhìn tổng quan và sâu sắc hơn về OOP.\nTrong bài viết này mình sẽ lấy ví dụ khá nhiều thông qua ngôn ngữ Java nhé.\n Overview  Theo Wikipedia viết:\n“Lập trình hướng đối tượng (tiếng Anh: Object-oriented programming, viết tắt: OOP) là một mẫu hình lập trình dựa trên khái niệm \u0026ldquo;công nghệ đối tượng\u0026rdquo;, mà trong đó, đối tượng chứa đựng các dữ liệu, trên các trường, thường được gọi là các thuộc tính; và mã nguồn, được tổ chức thành các phương thức\u0026hellip;”\nKhá khó hiểu đúng không, nhưng khi nghe tên “hướng đối tượng” là các bạn cũng có thể mường tượng ra kỹ thuật này sẽ xoay quanh tới 1 đối tượng (Object). Vậy lập trình hướng đối tượng là gì:\n“Lập trình hướng đối tượng ( Object - Oriented Programming) là một kỹ thuật mô hình hóa một hệ thống giống với thế giới thực trong phần mềm dựa trên các đối tượng.”\nVí dụ:\nTa có một đối tượng (Object) là một con chó. Vậy theo các bạn con chó này sẽ có những đặc điểm và hành vi gì? Đặc điểm: tên, màu lông, giống loài, xuất xứ…\nHành vi: ăn, chơi, sủa…\nVậy ta sẽ áp dụng vào code như nào\nĐó như các bạn thấy thì mình vừa tái hiện lại một đối tượng có thực trong thực tế vào trong lập trình. Chính vì thế người ta nói lập trình hướng đối tượng là một mô hình hóa hệ thống các đối tượng có thực vào trong phần mềm.\nObject và Class  Như đã nói phía trên, Object là những thực thể có thực trong hiện tại, vậy nếu sẽ ra sao khi chúng ta phải tạo hẳn 38 đối tượng chỉ để thể hiện từng bạn học sinh trong một lớp? Thật ngớ ngẩn. Chính vì lý do đó mà chúng ta sẽ có một khái niệm mới đó là Class. Class là một tập hợp các đối tượng có cùng chung những đặc điểm giống nhau. Ta có thể hiểu đơn giản, Class như một bản thiết kế nguyên thủy, nó bao gồm tất cả những thông tin cơ bản nhất mà một đối tượng phải có. Để khi nhìn vào một Class ta có thể hình dung được ngay bản thiết kế này sẽ cho ra một sản phẩm và sản phẩm được sinh ra từ bản thiết kế này được gọi là 1 Object.\nVậy ở đây ta có thể rút ra được 2 khái niệm cơ bản:\nClass: giống như một bản thiết kế dùng để tạo ra các Object (đối tượng), bản thân Class không phải là một Object.\nObject: được tạo ra từ một Class, các object được tạo ra từ Class nào sẽ có đầy đủ các thuộc tính của Class đó.\nBốn tính chất cơ bản của OOP   Trong Lập trình hướng đối tượng sẽ được chia thành 4 tính chất như sau:\n Tính kế thừa: Inheritance Tính đóng gói: Encapsulation Tính trừu tượng: Abstraction Tính đa hình: Polymorphism  \tVậy chúng ta sẽ đi tìm hiểu về tính chất đầu tiên.\n Tâm pháp tầng thứ nhất : Inheritance  Nghe đến kế thừa là các bạn có thể hình dung tính chất này nói về gì rồi đúng không. Nội dung của tính chất này như sau:\n“Tính kế thừa là chỉ việc một class có thể sử dụng lại những đặc điểm và tính chất của một class khác. Mục đích của tính chất này là giúp chúng ta dễ dàng mở rộng và tránh lặp code.”\nĐể dễ hiểu hơn ta có thể xem ví dụ ở dưới:\nỞ đây mình tạo ra một class có tên là Person với những đặc điểm, hành vi chung của con người:\nỞ đây với lớp Person ta có những đặc điểm và hành vi chung nhất, đây ta gọi là một Base Class.\nTiếp theo ta tạo một lớp con kế thừa lại lớp cha và đó là lớp Student\nỞ class Student, ta kế thừa lại tất cả những thuộc tính và phương thức (method) của lớp cha thông qua từ khóa extends. Như bạn đã thấy thì ta cũng có thể thêm những đặc điểm, method riêng mà chỉ học sinh mới có, như vậy ta sẽ tránh bị lặp code.\nĐể có thể hiểu sâu hơn, tính kế thừa được chia ra làm 4 loại:\n1.1. Đơn kế thừa (Single Inheritance)\n\tĐối với Đơn kế thừa, một lớp sẽ kế thừa những thuộc tính của một lớp khác. Nó cho phép một lớp con kế thừa những thuộc tính và hành vi (method) từ một lớp cha.\nĐiều này sẽ cho phép code khả năng tái sử dụng code cũng như thêm các tính năng mới vào các đoạn code hiện có.\nỞ ví dụ bên trên, Class Person là lớp cha và Class Student là lớp con với những thuộc tính và hành vi của lớp cha.\n1.2. Kế thừa đa cấp (Multilevel Inheritance)\n\tKhi một lớp được bắt nguồn từ một lớp mà cũng là lớp con (kế thừa từ một lớp khác). Tức là một lớp có nhiều hơn một cấp cha, kiểu kế thừa đó được gọi là kế thừa kiểu Đa cấp.\nVẫn tiếp tục ở ví dụ trên, nếu bây giờ tôi tạo ra một lớp dành cho đối tượng học sinh giỏi thì sẽ extends lại lớp Student, lúc này class Student là lớp cha và class Person là lớp ông của lớp AdvancedStudent 1.3. Kế thừa thứ bậc (Hierarchical Inheritance)\nKhi một lớp có nhiều hơn một lớp con hoặc nói cách khác là có nhiều hơn một lớp con có cùng chung một lớp cha, lúc này loại kế thừa này được gọi là thứ bậc (hierarchical).\nTrong thực tế đâu chỉ có mỗi đối tượng học sinh là giống con người đúng không, ta còn có thể tạo ra nhiều lớp kế thừa lại lớp Person ban đầu.\n1.4. Kế thừa lai (Hybrid Inheritance)\n“Sao chỉ có thể kế thừa 1 lớp thôi ạ, bây giờ em muốn kế thừa nhiều hơn một lớp được không, chứ như này hơi bất tiện cả không tối ưu lắm???”\nRất tiếc là để tránh sự phức tạp cho nên trong Java không hỗ trợ sự đa kế thừa giữa các Class với nhau. Tuy nhiên, vẫn có cách để chúng ta đạt được sự đa kế thừa đó là sử dụng Interface thông qua từ khóa Implements.\nĐể dễ hiểu hơn mình sẽ có ví dụ như sau: Mỗi lớp trên đều có điểm chung là thuộc tính và hành vi, vậy thì mình sẽ tách riêng ra để có thể thực hiện kế thừa lai.\nỞ đây mình tạo ra 3 interface là  IStudy (gồm những method cơ bản của một học sinh)  IDev (gồm những môn bắt buộc của một học sinh CNTT) IAdvanced (gồm môn học của một học sinh giỏi)  Sau đó mình sẽ cho các lớp đối tượng sinh viên implement những interface cần thiết để có thể sử dụng.\nNhư vậy ta đã có thể giải quyết được vấn đề đơn kế thừa trong Java rồi đúng không. Qua những ví dụ trên mong các bạn hiểu được tính chất đầu tiên này trong OOP. Trong bài viết tiếp theo, chúng ta sẽ đi tới tính chất thứ hai trong OOP đó là tính đóng gói.\nTài liệu tham khảo:\n Head First - Java. https://www.javatpoint.com/abstract-class-in-java  ","description":"OOP không phải là chủ đề dễ, những cũng không quá khó nếu chúng ta đầu tư tìm hiểu...","id":6,"section":"posts","tags":["oop","java","học thuật"],"title":"OOP - Những điều chưa kể (Phần 1)","uri":"https://hai-nguyen-21.github.io/posts/oop1/"}]