[{"content":"Tiếp nối bài viết trước, chúng ta dừng lại ở tính chất thứ nhất, hôm nay tôi sẽ giới thiệu tiếp cho các bạn 3 tính chất còn lại của lập trình hướng đối tượng nhé.\nTâm pháp tầng thứ hai : Encapsulation  Nghe đến đây chắc hẳn các bạn cũng đã mường tượng ra tính chất này nói về cái gì rồi đúng không? Và nội dung của tính chất này được hiểu như sau:\n“Tính đóng gói là một cơ chế liên kết dữ liệu và code chung với nhau thành một đơn vị duy nhất. Nó cũng được hiểu với mục đích che giấu dữ liệu của bạn để đảm bảo toàn vẹn dữ liệu từ những chỉnh sửa bên ngoài.”\nVậy tức là sao?\nNhưng trước khi vào thực hành ta nên đi qua chút lý thuyết nhé. Tính đóng gói có 4 kiểu phạm vi truy cập (Access Modifier) như sau:\n Default (mặc định) : Nếu như bạn không khai báo phạm vi truy cập thì Java sẽ hiểu mặc định phạm vi truy cập là default. Với default thì trong lớp (class) đó và trong gói (package) đó mới có thể nhìn thấy được. Private (riêng tư) : Nếu như bạn khai báo phạm vi truy cập là private thì chỉ có thể sử dụng ở ngay trong chính lớp đó thôi. Public (công khai) : Nếu như bạn khai báo ở dạng public thì mọi thông tin trong lớp đó đều có thể được nhìn thấy từ các lớp (class), các gói (package), hay là class con (subclass) Protected (được bảo vệ) : Nếu bạn khai báo ở dạng này thì lớp (class) đó, gói (package) đó, lớp con (subclass) đó đều có thể thấy được.  NOTE: Có thể nhiều bạn sẽ hiểu lầm về public và protected nhưng phạm vi của pubic nó rất rộng, bạn có thể truy cập vào 1 class với các thuộc tính được public từ package này sang package khác, còn protected thì không, nó chỉ hoạt động trong chính package của nó mà thôi.\nĐể dễ hiểu thì các bạn có thể xem ví dụ ở dưới đây\nCó phải từ những ví dụ trên mình đều lấy ví dụ cho các bạn như thế này đúng không:\nCode ở trên cơ bản là không sai, nó vẫn chạy và diễn ra bình thường, tuy nhiên không ai mong muốn một ngày đẹp trời bạn vào xem sản phẩm của mình và bị thay đổi dữ liệu tùm lum đúng không. Để giải quyết vấn đề đó cho nên ta cần phải private hết dữ liệu lại để tránh bị sửa code từ những tác nhân bên ngoài. “Ơ nhưng private rồi thì sao có thể truy cập được từ các class khác?” Chính vì thế nên Java mới có thêm 2 phương thức thần kỳ đó chính là Getter và Setter, hai phương thức này chuyên dùng để có thể Lấy và Ghi dữ liệu. Như vậy từ lần sau, chúng ta nên khai báo một lớp với những phạm vi truy cập ở dạng private để có thể bảo toàn dữ liệu và truy cập tới chúng thông qua phương thức Get và Set.\nNhìn qua một lượt ví dụ trên có bạn nào thắc mắc về dòng code này không?\nĐây được gọi là Constructor không tham số, Constructor này sẽ luôn được mặc định gọi ra kể cả khi bạn có khai báo hay không. Ngoài Constructor không tham số ta cũng có Constructor có tham số, riêng Constructor có tham số thì bắt buộc bạn phải khai báo. Constructor có tham số có nhiệm vụ giống với Get và Set, bạn có thể truyền dữ liệu vào đó mà không cần Get và Set.\nNhư vậy là các bạn đã hiểu về tính chất thứ 2 trong OOP rồi, tiếp theo ta sẽ đến với tính chất thứ 3 đó là tính trừu tượng.\nTâm pháp tầng thứ ba : Abstraction  Vậy trừu tượng nghĩa là sao? Theo mình thì trừu tượng cũng như một tảng băng chìm vậy, ta chỉ có thể nhìn được những bề nổi và nhận ra nó sẽ làm gì còn bề dưới tảng băng ta không hề hay biết nó to hay nhỏ, kích thước ra sao.\nVậy từ đây mình có thể giải thích ngắn gọn về tính chất này như sau:\n“Tính trừu tượng là một tiến trình ẩn các chi tiết trình triển khai và chỉ hiển thị tính năng tới người dùng. Tính trừu tượng cho phép bạn loại bỏ tính chất phức tạp của đối tượng bằng cách chỉ đưa ra các thuộc tính và phương thức cần thiết của đối tượng trong lập trình.”\nCó hai cách để ta có thể triển khai được tính trừu tượng:\n Sử dụng Abstract Class Sử dụng Interface  \t3.1. Abstract Class\nMột lớp được khai báo với từ khóa abstract tức là một lớp abstract. Lúc này bạn sẽ không thể sử dụng từ khóa “new”, có nghĩa là bạn không thể tạo instance từ một lớp trừu tượng. Cách duy nhất đó là dùng một lớp con kế thừa lại lớp abstract class. Để dễ hiểu mình có ví dụ như sau:\nBên trên mình có tạo ra một abstract class với phương thức rỗng là draw();. Sau đó mình có tạo thêm một lớp con là Rectangle kế thừa lại lớp Shape để sử dụng lại method. Kết quả:\nLúc này lớp abstract đóng vai trò như một base class, khai báo tất cả những method cơ bản và cần thiết nhất để các lớp khác có thể tái sử dụng mà không cần viết lại code. Tuy nhiên khi ta extends một class Abstract thì ta phải Override lại toàn bộ methods đã được khai báo.\n3.2. Interface Như ví dụ bên trên mình đã giới thiệu cho các bạn về Interface rồi. Trong Interface thì chỉ có thể khai báo các method rỗng (tức không có body code) để các lớp khác khi implements sẽ khai báo và sử dụng lại methods đó.\nTuy nhiên khi lên Java 8 thì Interface được hỗ trợ defaults methods, lúc này bạn có thể triển khai body code trong một Interface.\nĐể hiểu rõ hơn về defaults methods bạn có thể đọc bài viết này: Vậy sự khác nhau giữa Abstract class và Interface là gì?    Abstract Class Interface     Thể hiện tính trừu tượng \u0026lt;100%  Thể hiện tính trừu tượng 100% (\u0026lt; Java 8)   Lớp trừu tượng không hỗ trợ đa kế thừa Interface có hỗ trợ đa kế thừa   Lớp trừu tượng có thể có phương thức static, phương thức main và constructor. Không có phương thức static, phương thức main và constructor.\n\n   Từ khóa abstract để khai báo một lớp abstract Từ khóa interface để khai báo một lớp Interface.   Lớp trừu tượng có thể cung cấp trình triển khai của một Interface Interface không thể cung cấp trình triển khai cụ thể của lớp abstract.    \tCuối cùng là tính chất thứ 4, tính đa hình.\nTâm pháp tầng thứ tư : Polymorphism  Trong tiếng Anh, “poly” nghĩa là nhiều, “morph” có nghĩa là hình thức. Đa hình có thể là một biến, một chức năng, một đối tượng được đưa vào sử dụng dưới nhiều hình thức khác nhau.\n\tĐể dễ hiểu nhất về tính chất này, bạn có thể liên tưởng đến những diễn viên vậy, ở bộ phim này họ đóng vai ác, đến bộ phim sau họ đóng vai hiền. \tVậy ta phải sử dụng tính đa hình như thế nào trong lập trình OOP. Trước mắt ta phải hiểu rõ, khi nói đến đa hình là phải đi kèm với kế thừa. Bởi vì để một đối tượng nào đó có thể nhập vai vào một đối tượng khác thù chỉ có thể một đối tượng cha, và ở đây lớp cn sẽ phải ghi đè (Overriding) lại các phương thức của lớp cha.\nTa hãy cùng xem ví dụ dưới đây:\nNgoài ra ta còn có Overloading để thể hiện tính đa hình. Vậy sự khác biệt giữa Overriding và Overloading là gì?\n Overloading (nạp chồng) Đây là khả năng cho phép một lớp có nhiều thuộc tính, phương thức cùng tên nhưng với các tham số khác nhau về loại cũng như về số lượng. Khi được gọi, dựa vào tham số truyền vào, phương thức tương ứng sẽ được thực hiện.  Overriding (ghi đè) là hai phương thức cùng tên, cùng tham số, cùng kiểu trả về nhưng thằng con viết lại và dùng theo cách của nó, và xuất hiện ở lớp cha và tiếp tục xuất hiện ở lớp con. Khi dùng override, lúc thực thi, nếu lớp Con không có phương thức riêng, phương thức của lớp Cha sẽ được gọi, ngược lại nếu có, phương thức của lớp Con được gọi.  Để dễ hiểu các bạn có thể hiểu Overloading như sau: Nếu một lớp có nhiều phương thức cùng tên nhưng khác nhau về tham số hay kiểu dữ liệu thì đó chính là nạp chồng phương thức.\nNhư vậy mình đã giới thiệu cho các bạn về tất cả 4 tính chất trong OOP rồi. Hy vọng bài viết này sẽ giúp các bạn có cái nhìn bao quát hơn về lập trình hướng đối tượng, từ đó sẽ giúp các bạn hiểu rõ hơn về những kiến thức bao la phía sau.\nTài liệu tham khảo:\n Head First - Java. https://www.javatpoint.com/abstract-class-in-java  ","description":"OOP không phải là chủ đề dễ, những cũng không quá khó nếu chúng ta đầu tư tìm hiểu...","id":0,"section":"posts","tags":["oop","java"],"title":"OOP - Những điều chưa kể (Phần 2)","uri":"https://hai-nguyen-21.github.io/posts/oop2/"},{"content":"Lambda Expression- Tính năng thú vị của Java 8\n Định nghĩa  - Là một hàm không có tên (anonymous function) với các tham số (parameters) và nội dung thực thi (body).\n- Nội dung thực thi của Lambda expression có thể là một khối lệnh hoặc một biểu thức.\n- Dấu “-\u0026gt;” tách biệt các tham số và nội dung thực thi.\n Cú pháp  (argument-list) -\u0026gt; {body}\n+ Argument-list : danh sách tham số, có thể không có, có một hoặc nhiều tham số.\n+ Arrow-operator: toán tử mũi tiên được sử dụng để liên kết danh sách tham số và body của biểu thức.\n+ Body: nội dung thực thi, là 1 khối lệnh hoặc 1 biểu thức.\n Ví dụ  () -\u0026gt; \u0026ldquo;Hello\u0026rdquo; Không có tham số và trả về một chuỗi\n(double x) -\u0026gt; x + 1 Có một tham số x và trả về giá trị tham số tăng lên 1\n(int x, int y) -\u0026gt; x + y Có 2 tham số kiểu int và trả về tổng\n Một số quy tắc trong Lambda Expression Có thể bỏ qua kiểu dữ liệu của parameter truyền vào  (String msg) -\u0026gt; {System.out.println (msg);} =\u0026gt; (msg) -\u0026gt; {System.out.println (msg);}  Nếu không có parameter ,bỏ dấu () trống  () -\u0026gt; {System.out.println (“Hello”);}  Nếu chỉ có 1 parameter, có thể bỏ luôn dấu ()  (double x) -\u0026gt; x + 1 =\u0026gt; x -\u0026gt; x+1\n Nếu anonymous function chỉ có 1 câu lệnh , có thể bỏ dấu {}   (msg) -\u0026gt; {System.out.println (msg);} =\u0026gt; msg -\u0026gt; System.out.println (msg);  Nếu chỉ return 1 giá trị , có thể bỏ chữ return  x -\u0026gt; return x + 1 =\u0026gt; x -\u0026gt; x + 1  Ứng dụng  Duyệt List  Cách 1 – for i      for (int i = 0; i \u0026lt; listNV.size(); i++) {\n listNV.get(i).xuat();\n }\n Cách 2 – for each  for(NhanVien x:listNV){\n x.xuat();\n}\n Cách 3 – biểu thức Lambda  listNV.forEach(x -\u0026gt; {\n x.xuat();\n });\n Sắp xếp chuỗi  Cách cũ    public void sortByName() {\nComparator com = new Comparator\u0026lt; Staff \u0026gt;() {\n @Override\n public int compare(Staff o1, Staff o2) {\n return o1.getName ().compareTo(o2.getName ());\n }\n };\n listNV.sort(com);\n System.out.println(\u0026ldquo;DSNV sắp theo họ tên là:\u0026quot;);\n xuatDSNV();\n }\n Cách 1 – dùng Lambda theo Collections  public void sortByName () {\n Collections.sort(listNV, (Staff o1, Staff o2)\n -\u0026gt; {\n return o1.getName ().compareToIgnoreCase(o2.getName ());\n });\n System.out.println(\u0026ldquo;DSNV sắp theo họ tên là:\u0026quot;);\n xuatDSNV();\n }\n Cách 2 – cũng là Collections nhưng ngắn hơn 😊)  public void sortByName () {\n listNV.sort((o1, o2)-\u0026gt; {\n return o1.getName ().compareTo(o2.getName ());\n });\n System.out.println(\u0026ldquo;DSNV sắp theo họ tên là:\u0026quot;);\n xuatDSNV();\n","description":"Java 8 mở ra cho cho chúng ta những thứ khiến cộng việc học lập trình trở nên thú vị hơn...","id":1,"section":"posts","tags":["java"],"title":"Lambda Expression và những điều thú vị.","uri":"https://hai-nguyen-21.github.io/posts/lambda-expression/"},{"content":" [NHỮNG ĐIỀU CƠ BẢN VỀ OOP MÀ BẠN CHƯA BIẾT]\nNếu như những ai học lập trình thì không còn quá xa lạ với chủ đề này nhưng để hiểu nó thì không phải ai cũng có thể hiểu được luôn. Chính vì vậy hôm nay mình sẽ giới thiệu lại cho mọi người để có cái nhìn tổng quan và sâu sắc hơn về OOP.\nTrong bài viết này mình sẽ lấy ví dụ khá nhiều thông qua ngôn ngữ Java nhé.\n Overview  Theo Wikipedia viết:\n“Lập trình hướng đối tượng (tiếng Anh: Object-oriented programming, viết tắt: OOP) là một mẫu hình lập trình dựa trên khái niệm \u0026ldquo;công nghệ đối tượng\u0026rdquo;, mà trong đó, đối tượng chứa đựng các dữ liệu, trên các trường, thường được gọi là các thuộc tính; và mã nguồn, được tổ chức thành các phương thức\u0026hellip;”\nKhá khó hiểu đúng không, nhưng khi nghe tên “hướng đối tượng” là các bạn cũng có thể mường tượng ra kỹ thuật này sẽ xoay quanh tới 1 đối tượng (Object). Vậy lập trình hướng đối tượng là gì:\n“Lập trình hướng đối tượng ( Object - Oriented Programming) là một kỹ thuật mô hình hóa một hệ thống giống với thế giới thực trong phần mềm dựa trên các đối tượng.”\nVí dụ:\nTa có một đối tượng (Object) là một con chó. Vậy theo các bạn con chó này sẽ có những đặc điểm và hành vi gì? Đặc điểm: tên, màu lông, giống loài, xuất xứ…\nHành vi: ăn, chơi, sủa…\nVậy ta sẽ áp dụng vào code như nào\nĐó như các bạn thấy thì mình vừa tái hiện lại một đối tượng có thực trong thực tế vào trong lập trình. Chính vì thế người ta nói lập trình hướng đối tượng là một mô hình hóa hệ thống các đối tượng có thực vào trong phần mềm.\nObject và Class  Như đã nói phía trên, Object là những thực thể có thực trong hiện tại, vậy nếu sẽ ra sao khi chúng ta phải tạo hẳn 38 đối tượng chỉ để thể hiện từng bạn học sinh trong một lớp? Thật ngớ ngẩn. Chính vì lý do đó mà chúng ta sẽ có một khái niệm mới đó là Class. Class là một tập hợp các đối tượng có cùng chung những đặc điểm giống nhau. Ta có thể hiểu đơn giản, Class như một bản thiết kế nguyên thủy, nó bao gồm tất cả những thông tin cơ bản nhất mà một đối tượng phải có. Để khi nhìn vào một Class ta có thể hình dung được ngay bản thiết kế này sẽ cho ra một sản phẩm và sản phẩm được sinh ra từ bản thiết kế này được gọi là 1 Object.\nVậy ở đây ta có thể rút ra được 2 khái niệm cơ bản:\nClass: giống như một bản thiết kế dùng để tạo ra các Object (đối tượng), bản thân Class không phải là một Object.\nObject: được tạo ra từ một Class, các object được tạo ra từ Class nào sẽ có đầy đủ các thuộc tính của Class đó.\nBốn tính chất cơ bản của OOP   Trong Lập trình hướng đối tượng sẽ được chia thành 4 tính chất như sau:\n Tính kế thừa: Inheritance Tính đóng gói: Encapsulation Tính trừu tượng: Abstraction Tính đa hình: Polymorphism  \tVậy chúng ta sẽ đi tìm hiểu về tính chất đầu tiên.\n Tâm pháp tầng thứ nhất : Inheritance  Nghe đến kế thừa là các bạn có thể hình dung tính chất này nói về gì rồi đúng không. Nội dung của tính chất này như sau:\n“Tính kế thừa là chỉ việc một class có thể sử dụng lại những đặc điểm và tính chất của một class khác. Mục đích của tính chất này là giúp chúng ta dễ dàng mở rộng và tránh lặp code.”\nĐể dễ hiểu hơn ta có thể xem ví dụ ở dưới:\nỞ đây mình tạo ra một class có tên là Person với những đặc điểm, hành vi chung của con người:\nỞ đây với lớp Person ta có những đặc điểm và hành vi chung nhất, đây ta gọi là một Base Class.\nTiếp theo ta tạo một lớp con kế thừa lại lớp cha và đó là lớp Student\nỞ class Student, ta kế thừa lại tất cả những thuộc tính và phương thức (method) của lớp cha thông qua từ khóa extends. Như bạn đã thấy thì ta cũng có thể thêm những đặc điểm, method riêng mà chỉ học sinh mới có, như vậy ta sẽ tránh bị lặp code.\nĐể có thể hiểu sâu hơn, tính kế thừa được chia ra làm 4 loại:\n1.1. Đơn kế thừa (Single Inheritance)\n\tĐối với Đơn kế thừa, một lớp sẽ kế thừa những thuộc tính của một lớp khác. Nó cho phép một lớp con kế thừa những thuộc tính và hành vi (method) từ một lớp cha.\nĐiều này sẽ cho phép code khả năng tái sử dụng code cũng như thêm các tính năng mới vào các đoạn code hiện có.\nỞ ví dụ bên trên, Class Person là lớp cha và Class Student là lớp con với những thuộc tính và hành vi của lớp cha.\n1.2. Kế thừa đa cấp (Multilevel Inheritance)\n\tKhi một lớp được bắt nguồn từ một lớp mà cũng là lớp con (kế thừa từ một lớp khác). Tức là một lớp có nhiều hơn một cấp cha, kiểu kế thừa đó được gọi là kế thừa kiểu Đa cấp.\nVẫn tiếp tục ở ví dụ trên, nếu bây giờ tôi tạo ra một lớp dành cho đối tượng học sinh giỏi thì sẽ extends lại lớp Student, lúc này class Student là lớp cha và class Person là lớp ông của lớp AdvancedStudent 1.3. Kế thừa thứ bậc (Hierarchical Inheritance)\nKhi một lớp có nhiều hơn một lớp con hoặc nói cách khác là có nhiều hơn một lớp con có cùng chung một lớp cha, lúc này loại kế thừa này được gọi là thứ bậc (hierarchical).\nTrong thực tế đâu chỉ có mỗi đối tượng học sinh là giống con người đúng không, ta còn có thể tạo ra nhiều lớp kế thừa lại lớp Person ban đầu.\n1.4. Kế thừa lai (Hybrid Inheritance)\n“Sao chỉ có thể kế thừa 1 lớp thôi ạ, bây giờ em muốn kế thừa nhiều hơn một lớp được không, chứ như này hơi bất tiện cả không tối ưu lắm???”\nRất tiếc là để tránh sự phức tạp cho nên trong Java không hỗ trợ sự đa kế thừa giữa các Class với nhau. Tuy nhiên, vẫn có cách để chúng ta đạt được sự đa kế thừa đó là sử dụng Interface thông qua từ khóa Implements.\nĐể dễ hiểu hơn mình sẽ có ví dụ như sau: Mỗi lớp trên đều có điểm chung là thuộc tính và hành vi, vậy thì mình sẽ tách riêng ra để có thể thực hiện kế thừa lai.\nỞ đây mình tạo ra 3 interface là  IStudy (gồm những method cơ bản của một học sinh)  IDev (gồm những môn bắt buộc của một học sinh CNTT) IAdvanced (gồm môn học của một học sinh giỏi)  Sau đó mình sẽ cho các lớp đối tượng sinh viên implement những interface cần thiết để có thể sử dụng.\nNhư vậy ta đã có thể giải quyết được vấn đề đơn kế thừa trong Java rồi đúng không. Qua những ví dụ trên mong các bạn hiểu được tính chất đầu tiên này trong OOP. Trong bài viết tiếp theo, chúng ta sẽ đi tới tính chất thứ hai trong OOP đó là tính đóng gói.\n","description":"OOP không phải là chủ đề dễ, những cũng không quá khó nếu chúng ta đầu tư tìm hiểu...","id":2,"section":"posts","tags":["oop","java"],"title":"OOP - Những điều chưa kể (Phần 1)","uri":"https://hai-nguyen-21.github.io/posts/oop1/"}]